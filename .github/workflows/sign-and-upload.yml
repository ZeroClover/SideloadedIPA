name: Sign and Upload IPAs

on:
  schedule:
    - cron: '0 2 * * *'  # Daily at 02:00 UTC
  workflow_dispatch:
    inputs:
      debug:
        description: Enable SSH Debug
        required: false
        default: false
        type: boolean
      force_rebuild:
        description: Force full rebuild (ignore cache)
        required: false
        default: false
        type: boolean
  repository_dispatch:
    types: [sign_ipas]

permissions:
  contents: read

concurrency:
  group: sign-and-upload
  cancel-in-progress: false

jobs:
  sign-and-upload:
    name: Sign & Upload IPAs
    runs-on: macos-latest
    env:
      # Apple Developer credentials
      APPLE_DEV_CERT_P12_ENCODED: ${{ secrets.APPLE_DEV_CERT_P12_ENCODED }}
      APPLE_DEV_CERT_PASSWORD: ${{ secrets.APPLE_DEV_CERT_PASSWORD }}
      # App Store Connect API
      ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
      ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
      ASC_PRIVATE_KEY: ${{ secrets.ASC_PRIVATE_KEY }}
      # Asset server
      ASSETS_SERVER_IP: ${{ secrets.ASSETS_SERVER_IP }}
      ASSETS_SERVER_USER: ${{ secrets.ASSETS_SERVER_USER }}
      ASSETS_SERVER_CREDENTIALS: ${{ secrets.ASSETS_SERVER_CREDENTIALS }}
      # GitHub Token for API access (authenticated rate limits)
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      # Enable verbose logging in scripts (used for GitHub API rate limit debug)
      DEBUG: ${{ github.event.inputs.debug || 'false' }}
      # Force rebuild flag
      FORCE_REBUILD: ${{ github.event.inputs.force_rebuild || 'false' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up Python with uv
        uses: astral-sh/setup-uv@v7
        with:
          enable-cache: true
          cache-dependency-glob: "uv.lock"

      - name: Install Python dependencies
        run: uv sync --frozen

      - name: Restore cache
        id: cache-restore
        uses: actions/cache/restore@v5
        with:
          path: |
            work/cache
          key: ci-cache-v1-${{ github.ref_name }}-${{ hashFiles('configs/tasks.toml') }}-${{ github.run_id }}
          restore-keys: |
            ci-cache-v1-${{ github.ref_name }}-${{ hashFiles('configs/tasks.toml') }}-
            ci-cache-v1-${{ github.ref_name }}-
            ci-cache-v1-

      - name: Preserve cached device list for comparison
        run: |
          mkdir -p work/cache-old
          if [ -f work/cache/device-list.json ]; then
            cp work/cache/device-list.json work/cache-old/device-list.json
            echo "Preserved cached device list for comparison"
          else
            echo "No cached device list found (first run)"
          fi

      - name: Import Apple signing certs into Keychain
        id: import-certs
        uses: apple-actions/import-codesign-certs@v6
        with:
          # Uses default keychain name 'signing_temp' and create-keychain: true
          p12-file-base64: ${{ env.APPLE_DEV_CERT_P12_ENCODED }}
          p12-password: ${{ env.APPLE_DEV_CERT_PASSWORD }}

      - name: Resolve keychain path and discover identity
        run: |
          # Construct the keychain path based on the default naming convention
          kc_path="$HOME/Library/Keychains/signing_temp.keychain-db"
          echo "KEYCHAIN_PATH=$kc_path" >> "$GITHUB_ENV"

          # Debug: Show keychain path and check if file exists
          echo "Using keychain path: $kc_path"
          echo "Keychain exists: $(test -f "$kc_path" && echo 'yes' || echo 'no')"
          echo "Keychain permissions: $(ls -la "$kc_path" 2>/dev/null || echo 'file not found')"

          # Ensure keychain is unlocked (action should do this, but be safe)
          if [[ -n "${{ steps.import-certs.outputs.keychain-password }}" && -f "$kc_path" ]]; then
            security unlock-keychain -p "${{ steps.import-certs.outputs.keychain-password }}" "$kc_path" || true
          fi

          # Discover a valid codesigning identity from that keychain specifically
          echo "Searching for identities in: $kc_path"
          ident=$(security find-identity -v -p codesigning "$kc_path" | awk -F '"' '/Apple (Development|Distribution)|iPhone/{print $2; exit}')
          if [[ -z "$ident" ]]; then
            echo "No code signing identity found in $kc_path" >&2
            echo "Full output from security find-identity:"
            security find-identity -v -p codesigning "$kc_path" || true
            exit 1
          fi
          echo "Found identity: $ident"
          echo "CODESIGN_IDENTITY=$ident" >> "$GITHUB_ENV"

      - name: Install dependencies
        run: |
          brew update
          brew install hudochenkov/sshpass/sshpass
          gem install bundler:2.5.23
          bundle _2.5.23_ install

      - name: Check Entitlements Profile
        id: check-entitlements
        run: |
          bundle exec ruby scripts/sync_profiles.rb check

      - name: Check App Version
        id: check-version
        env:
          DEVICES_CHANGED: ${{ steps.check-entitlements.outputs.devices_changed }}
        run: |
          uv run python scripts/check_changes.py

      - name: Sync Entitlements Profile
        env:
          DEVICES_CHANGED: ${{ steps.check-entitlements.outputs.devices_changed }}
          ALL_PROFILES_PRESENT: ${{ steps.check-entitlements.outputs.all_profiles_present }}
          MISSING_PROFILES: ${{ steps.check-entitlements.outputs.missing_profiles }}
        run: |
          set -euo pipefail
          echo "DEVICES_CHANGED=${DEVICES_CHANGED}"
          echo "ALL_PROFILES_PRESENT=${ALL_PROFILES_PRESENT}"
          echo "MISSING_PROFILES=${MISSING_PROFILES}"
          if [[ "${DEVICES_CHANGED}" == "true" ]]; then
            echo "Device list changed - regenerating all provisioning profiles"
            bundle exec ruby scripts/sync_profiles.rb
          else
            echo "Device list unchanged - downloading existing profiles (create missing if needed)"
            SKIP_PROFILE_REGENERATION=true bundle exec ruby scripts/sync_profiles.rb
          fi

      - name: Run signer
        env:
          REBUILD_ALL: ${{ steps.check-version.outputs.rebuild_all }}
          REBUILD_TASKS: ${{ steps.check-version.outputs.rebuild_tasks }}
        run: uv run python scripts/run_signing.py

      - name: Save cache
        if: always()
        uses: actions/cache/save@v5
        continue-on-error: true
        with:
          path: |
            work/cache
          key: ci-cache-v1-${{ github.ref_name }}-${{ hashFiles('configs/tasks.toml') }}-${{ github.run_id }}

      - name: "Debug: Configure SSH public key for runner"
        if: ${{ always() && github.event_name == 'workflow_dispatch' && (github.event.inputs.debug == true || github.event.inputs.debug == 'true' || github.event.inputs.debug == '1') }}
        env:
          PUBKEY: ${{ secrets.DEBUG_SSH_PUBLIC_KEY }}
        run: |
          set -euo pipefail
          if [[ -z "${PUBKEY:-}" ]]; then
            echo "DEBUG_SSH_PUBLIC_KEY is required when debug is enabled." >&2
            exit 1
          fi
          mkdir -p "$HOME/.ssh"
          chmod 700 "$HOME/.ssh"
          echo "$PUBKEY" > "$HOME/.ssh/authorized_keys"
          chmod 600 "$HOME/.ssh/authorized_keys"

      - name: "Debug: Enable SSH Server"
        if: ${{ always() && github.event_name == 'workflow_dispatch' && (github.event.inputs.debug == true || github.event.inputs.debug == 'true' || github.event.inputs.debug == '1') }}
        run: |
          set -euxo pipefail
          # Ensure pubkey auth is enabled and password auth disabled
          # Enable Remote Login and ensure sshd is loaded and started
          sudo systemsetup -setremotelogin on

      - name: "Debug: Install cloudflared"
        if: ${{ always() && github.event_name == 'workflow_dispatch' && (github.event.inputs.debug == true || github.event.inputs.debug == 'true' || github.event.inputs.debug == '1') }}
        run: |
          set -euxo pipefail
          brew install cloudflared

      - name: "Debug: Run cloudflared tunnel"
        if: ${{ always() && github.event_name == 'workflow_dispatch' && (github.event.inputs.debug == true || github.event.inputs.debug == 'true' || github.event.inputs.debug == '1') }}
        run: |
          set -euo pipefail
          cloudflared --no-autoupdate --url "ssh://localhost:22" 2>&1 | tee cloudflared.log

      - name: Notify webhook
        if: ${{ always() && (job.status == 'success' || job.status == 'failure') }}
        env:
          WEBHOOK_URL: ${{ secrets.Instatus_Webhook_URL }}
          JOB_STATUS: ${{ job.status }}
        run: |
          set -euo pipefail
          payload='{"trigger":"down"}'
          if [[ "${JOB_STATUS}" == "success" ]]; then
            payload='{"trigger":"up"}'
          fi
          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "$payload" \
            "$WEBHOOK_URL"
